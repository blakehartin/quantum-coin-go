// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.
/*
 * QC Read API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: v1
 */

package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/QuantumCoinProject/qc/log"
	"io/ioutil"
	"net"
	"net/http"
	"os"
	qcreadapi "github.com/QuantumCoinProject/qc/relay/qcreadapi"
	qcwriteapi "github.com/QuantumCoinProject/qc/relay/qcwriteapi"
	cachemanager "github.com/QuantumCoinProject/qc/cachemanager"
	"github.com/QuantumCoinProject/qc/relay"
	"strconv"
	"strings"
)

const VERSION_NUMBER = "v1.0.1"


type Configs struct {
	Configs []relay.RelayConfig `json:"configs"`
}

func main() {

	fmt.Println("==========================================")
	fmt.Println("||             Quantum Coin              ||")
	fmt.Println("||                   Q                   ||")
	fmt.Println("||  Quantum Resistant Blockchain Relay   ||")
	fmt.Println("==========================================")
	fmt.Println("VERSION_NUMBER", VERSION_NUMBER)

	if len(os.Args) < 2 {
		printHelp()
		return
	}

	file := os.Args[1]
	configs, err := readConfigJsonDataFile(file)

	if err != nil {
		fmt.Println(err.Error())
		return
	}

	if len(configs) < 1 {
		fmt.Println("Check config json file")
		return
	}

	for _, config := range configs{
		api := config.Api
		ip := config.Ip
		port := config.Port
		nodeUrl := config.NodeUrl
		corsAllowedOrigins := config.CorsAllowedOrigins
		enableAuth := config.EnableAuth
		apiKeys := config.ApiKeys
		cachePath := config.CachePath

		if net.ParseIP(ip) == nil {
			fmt.Println("Check configuration ip value ", ip)
			return
		}

		if _, err := strconv.Atoi(port); err != nil {
			fmt.Println("Check configuration port value ", port)
			return
		}

		if len(strings.TrimSpace(nodeUrl)) == 0{
			fmt.Println("Check configuration  node Url value", nodeUrl)
			return
		}

		if strings.EqualFold(api ,"read") {
			if len(strings.TrimSpace(cachePath)) == 0 {
				fmt.Println("Check configuration cache path value", cachePath)
				return
			}

			cacheManager, err := cachemanager.NewCacheManager(cachePath, nodeUrl, config.EnableExtendedApis, config.GenesisFilePath, config.MaxSupply)
			if err != nil {
				log.Error("NewCacheManager failed", "error", err)
				panic(err)
			}
			go qcReadApi(ip, port, nodeUrl, corsAllowedOrigins,enableAuth,apiKeys, cacheManager, config.EnableExtendedApis)
		}

		if strings.EqualFold(api ,"write") {
			go qcWriteApi(ip, port, nodeUrl, corsAllowedOrigins,enableAuth,apiKeys)
		}
	}

	fmt.Println("Relay listen and server...")
	<-make(chan int)
}

func qcReadApi(ip string, port string, nodeUrl string, corsAllowedOrigins string, enableAuth bool, apiKeys string, cacheManager *cachemanager.CacheManager, enableExtendedApis bool) {
	ReadApiAPIService, err := qcreadapi.NewReadApiAPIService(nodeUrl, cacheManager, enableExtendedApis)
	if err != nil {
		panic(err)
	}
	ReadApiAPIController := qcreadapi.NewReadApiAPIController(ReadApiAPIService, corsAllowedOrigins, enableAuth, apiKeys)
	readRouter := qcreadapi.NewRouter(ReadApiAPIController)

	fmt.Println("Read api server is listening on : ", ip + ":" + port, "nodeUrl" + ":" + nodeUrl, "corsAllowedOrigins" + ":" + corsAllowedOrigins)
	http.ListenAndServe(ip + ":" + port, readRouter)
}

func qcWriteApi(ip string, port string, nodeUrl string, corsAllowedOrigins string, enableAuth bool, apiKeys string) {
	WriteApiAPIService := qcwriteapi.NewWriteApiAPIService(nodeUrl)
	WriteApiAPIController := qcwriteapi.NewWriteApiAPIController(WriteApiAPIService, corsAllowedOrigins, enableAuth, apiKeys)
	writeRouter := qcwriteapi.NewRouter(WriteApiAPIController)

	fmt.Println("Write api server is listening on : ", ip + ":" + port, "nodeUrl" + ":" + nodeUrl, "corsAllowedOrigins" + ":" + corsAllowedOrigins)
	http.ListenAndServe(ip + ":" + port,  writeRouter)
}

func readConfigJsonDataFile(filename string)  ([]relay.RelayConfig, error) {
	if _, err := os.Stat(filename); err != nil {
		return nil, errors.New("File not found " + filename)
	}

	fileContent, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer fileContent.Close()

	byteResult, err  := ioutil.ReadAll(fileContent)
	if err != nil {
		return nil, err
	}

	byteResult = bytes.TrimPrefix(byteResult, []byte("\xef\xbb\xbf")) // Or []byte{239, 187, 191}

	var configs []relay.RelayConfig
	err = json.Unmarshal([]byte(byteResult), &configs)
	if err != nil {
		return nil, err
	}

	return configs, nil
}

func printHelp() {
	fmt.Println("===========")
	fmt.Println("relay config.json")
	fmt.Println("===========")
}
