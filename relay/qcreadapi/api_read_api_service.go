// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * QC Read API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: v1
 */

package qcreadapi

import (
	"fmt"
	"context"
	"encoding/json"
	"github.com/QuantumCoinProject/qc/log"
	"github.com/QuantumCoinProject/qc/relay"
	"github.com/QuantumCoinProject/qc/common"
	"github.com/QuantumCoinProject/qc/common/hexutil"
	"github.com/QuantumCoinProject/qc/rpc"
	"io/ioutil"
	"net/http"
	"errors"
	"github.com/mattn/go-colorable"
	"strconv"
	"time"
)

// ReadApiAPIService is a service that implements the logic for the ReadApiAPIServicer
// This service should implement the business logic for every endpoint for the ReadApiAPI API.
// Include any external packages or services that will be required by this service.
type ReadApiAPIService struct {
  DpUrl string
  CacheUrl string
}

type RPCTransaction struct {
	BlockHash        *common.Hash      `json:"blockHash"`
	BlockNumber      *hexutil.Big      `json:"blockNumber"`
	From             common.Address    `json:"from"`
	Gas              hexutil.Uint64    `json:"gas"`
	GasPrice         *hexutil.Big      `json:"gasPrice"`
	GasFeeCap        *hexutil.Big      `json:"maxFeePerGas,omitempty"`
	Hash             common.Hash       `json:"hash"`
	Input            hexutil.Bytes     `json:"input"`
	Nonce            hexutil.Uint64    `json:"nonce"`
	To               *common.Address   `json:"to"`
	TransactionIndex *hexutil.Uint64   `json:"transactionIndex"`
	Value            *hexutil.Big      `json:"value"`
	Type             hexutil.Uint64    `json:"type"`
}

// NewReadApiAPIService creates a default api service
func NewReadApiAPIService(dpUrl string, cacheUrl string) *ReadApiAPIService {
	log.Root().SetHandler(log.LvlFilterHandler(log.Lvl(3), log.StreamHandler(colorable.NewColorableStderr(), log.TerminalFormat(true))))
	return &ReadApiAPIService{
		DpUrl: dpUrl,
		CacheUrl: cacheUrl,
	}
}

// GetLatestBlockDetails - Get latest block details
func (s *ReadApiAPIService) GetLatestBlockDetails(ctx context.Context) (ImplResponse, error) {

	startTime := time.Now()

	log.Info(relay.InfoTitleLatestBlockDetails, relay.MsgDial, s.DpUrl)

	client, err := rpc.Dial(s.DpUrl)
	if err != nil {
		log.Error(relay.MsgDial, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}
	defer client.Close()

	var blockNumber *hexutil.Uint64
	err = client.CallContext(ctx, &blockNumber, "eth_blockNumber")
	if err != nil {
		log.Error(relay.MsgBlockNumber, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}

	latestBlockNumber, err := hexutil.DecodeBig(blockNumber.String())
	if err != nil {
		log.Error(relay.MsgBlockNumber, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusBadRequest)
		return Response(http.StatusBadRequest, nil), errors.New(err.Error())
	}

	duration := time.Now().Sub(startTime)

	log.Info(relay.InfoTitleLatestBlockDetails, "blockNumber", latestBlockNumber.Int64(),  relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusOK)
	l := latestBlockNumber.Int64()
	return Response(http.StatusOK, BlockDetailsResponse{BlockDetails{&l}}), nil
}

// GetAccountDetails - Get account details
func (s *ReadApiAPIService) GetAccountDetails(ctx context.Context, address string) (ImplResponse, error) {

	startTime := time.Now()

	log.Info(relay.InfoTitleAccountDetails, relay.MsgDial, s.DpUrl)

	client, err := rpc.Dial(s.DpUrl)
	if err != nil {
		log.Error(relay.MsgDial, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}
	defer client.Close()

	if !common.IsHexAddressDeep(address) {
		log.Error(relay.MsgAddress, relay.MsgAddress, address, relay.MsgError, relay.ErrInvalidAddress, relay.MsgStatus, http.StatusBadRequest)
		return Response(http.StatusBadRequest, nil), relay.ErrInvalidAddress
	}

	var balance *hexutil.Big
	err = client.CallContext(ctx, &balance, "eth_getBalance", common.HexToAddress(address), "latest")
	if err != nil {
		log.Error(relay.MsgBalance, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}

	var nonce *hexutil.Big
	err = client.CallContext(ctx, &nonce, "eth_getTransactionCount", common.HexToAddress(address), "latest")
	if err != nil {
		log.Error(relay.MsgNonce, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}

	var blockNumber *hexutil.Uint64
	err = client.CallContext(ctx, &blockNumber, "eth_blockNumber")
	if err != nil {
		log.Error(relay.MsgBlockNumber, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}

	accountBalance, err := hexutil.DecodeBig(balance.String())
	if err != nil {
		log.Error(relay.MsgBalance, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusBadRequest)
		return Response(http.StatusBadRequest, nil), errors.New(err.Error())
	}

	accountNonce, err := hexutil.DecodeBig(nonce.String())
	if err != nil {
		log.Error(relay.MsgNonce, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusBadRequest)
		return Response(http.StatusBadRequest, nil), errors.New(err.Error())
	}

	latestBlockNumber, err := hexutil.DecodeBig(blockNumber.String())
	if err != nil {
		log.Error(relay.MsgBlockNumber, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusBadRequest)
		return Response(http.StatusBadRequest, nil), errors.New(err.Error())
	}

	b := accountBalance.String()
	n := accountNonce.Int64()
	l := latestBlockNumber.Int64()

	duration := time.Now().Sub(startTime)

	log.Info(relay.InfoTitleAccountDetails, relay.MsgAddress, address, relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusOK)

	return Response(http.StatusOK, AccountDetailsResponse{
		AccountDetails{&b,&n,&l}}), nil
}

// GetTransactionDetails - Get transaction Details
func (s *ReadApiAPIService) GetTransactionDetails(ctx context.Context, hash string) (ImplResponse, error) {

	startTime := time.Now()
	isDiscarded := false
	discardReason := ""
	log.Info(relay.InfoTitleTransaction, relay.MsgDial, s.DpUrl)

	client, err := rpc.Dial(s.DpUrl)
	if err != nil {
		log.Error(relay.MsgDial,relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}
	defer client.Close()

	if !common.IsHexAddressDeep(hash)  {
		log.Error(relay.MsgHash, relay.MsgHash, hash, relay.MsgError, relay.ErrInvalidHash, relay.MsgStatus, http.StatusBadRequest)
		return  Response(http.StatusBadRequest, nil), relay.ErrInvalidHash
	}

	var raw json.RawMessage
	err =  client.CallContext(ctx, &raw, "eth_getTransactionByHash", common.HexToHash(hash))
	if err != nil {
		log.Error(relay.MsgTransaction, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return  Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}

	if raw != nil {

		var rpcTxn  *RPCTransaction

		err = json.Unmarshal(raw, &rpcTxn);
		if err != nil {
			log.Error(relay.MsgNonce, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusBadRequest)
			return Response(http.StatusBadRequest, nil), errors.New(err.Error())
		}

		var blochHash string
		var blockNumber int64
		var from, gas, gasPrice, txnHash, input, to string

		if rpcTxn.BlockHash != nil{
			blochHash = rpcTxn.BlockHash.String()
		}
		if rpcTxn.BlockNumber != nil {
			b := rpcTxn.BlockNumber.ToInt()
			blockNumber = b.Int64()
		}

		from = rpcTxn.From.String()
		gas = rpcTxn.Gas.String()
		gasPrice = rpcTxn.GasPrice.String()
		txnHash = rpcTxn.Hash.String()
		input = rpcTxn.Input.String()

		if rpcTxn.To != nil {
			to = rpcTxn.To.String()
		}

		transNonce := rpcTxn.Nonce
		n, err := hexutil.DecodeBig(transNonce.String())
		if err != nil {
			log.Error(relay.MsgNonce, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusBadRequest)
			return  Response(http.StatusBadRequest, nil), errors.New(err.Error())
		}

		nonce := n.Int64()

		value := rpcTxn.Value.String()

		var receipt map[string]interface{}
		err =  client.CallContext(ctx, &receipt, "eth_getTransactionReceipt", common.HexToHash(hash))
		if err != nil {
			log.Error(relay.MsgTransactionReceipt, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusServiceUnavailable)
			return  Response(http.StatusServiceUnavailable, nil), errors.New(err.Error())
		}

		var transactionReceipt  TransactionReceipt
		if receipt != nil {
			cumulativeGasUsed := receipt["cumulativeGasUsed"].(string)
			effectiveGasPrice := receipt["effectiveGasPrice"].(string)
			gasUsed := receipt["gasUsed"].(string)
			status := receipt["status"].(string)
			txnReceiptHash := receipt["transactionHash"].(string)
			t := receipt["type"].(string)
			transactionReceipt =  TransactionReceipt{
				cumulativeGasUsed, effectiveGasPrice, gasUsed,
				status, txnReceiptHash, t}
		} else {
			duration := time.Now().Sub(startTime)

			log.Info(relay.InfoTitleTransaction, relay.MsgHash, hash, relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusOK)

			txnDetails := TransactionDetails{
				&blochHash, &blockNumber, from,gas, gasPrice, txnHash,
				input, &isDiscarded, &discardReason, nonce , &to,value,
				transactionReceipt}

			Dump(txnDetails)

			return  Response(http.StatusOK, TransactionResponse{txnDetails}),	nil
		}
		duration := time.Now().Sub(startTime)

		log.Info(relay.InfoTitleTransaction, relay.MsgHash, hash, relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusOK)

		txnDetails := TransactionDetails{
			&blochHash, &blockNumber, from,gas, gasPrice, txnHash,
			input, &isDiscarded, &discardReason, nonce , &to,value,
			transactionReceipt}

		Dump(txnDetails)

		return Response(http.StatusOK,TransactionResponse{txnDetails}),	nil
	}

	duration := time.Now().Sub(startTime)

	log.Info(relay.InfoTitleTransaction, relay.MsgHash, hash, relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusNoContent)

	return  Response(http.StatusNotFound,nil), nil
}

// ListAccountTransactions - List account transactions
func (s *ReadApiAPIService) ListAccountTransactions(ctx context.Context, address string, pageNumber int64) (ImplResponse, error) {

	startTime := time.Now()

	log.Info(relay.InfoTitleListAccountTransactions, relay.MsgDial, s.CacheUrl)

	cacheClient := http.Client{
		Timeout: time.Second * 2, // Timeout after 2 seconds
	}

	if common.IsHexAddressDeep(address) == false {
		return Response(http.StatusInternalServerError, nil), relay.ErrInvalidAddress
	}

	url := s.CacheUrl + "/api/dogep/accounts/" + address + "/transactions/page/" +  strconv.Itoa(int(pageNumber))
	log.Info("ListAccountTransactions", "url", url)
	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}

	res, getErr := cacheClient.Do(req)
	if getErr != nil {
		return Response(http.StatusInternalServerError, nil), errors.New(getErr.Error())
	}

	if res.Body == nil {
		return Response(http.StatusInternalServerError, nil), errors.New("body is nil")
	}
	defer res.Body.Close()

	body, readErr := ioutil.ReadAll(res.Body)
	if readErr != nil {
		return Response(http.StatusInternalServerError, nil), errors.New(readErr.Error())
	}


	cacheResponse := ListAccountTransactionsResponseInternal{}
	jsonErr := json.Unmarshal(body, &cacheResponse)

	if jsonErr != nil {
		return Response(http.StatusInternalServerError, nil), errors.New(jsonErr.Error())
	}

	listResponse := ListAccountTransactionsResponse{}
	listResponse.PageCount = cacheResponse.PageCount
	listResponse.Items = make([]AccountTransactionCompact, len(cacheResponse.Items))

	for i,item := range  cacheResponse.Items {
		listItem := AccountTransactionCompact{}
		listItem.TxnHash = item.TxnHash

		listItem.BlockNumber = item.BlockNumber

		formattedTime, err := time.Parse("2006-01-02T15:04:05", item.CreatedAt)
		if err != nil {
			return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
		}

		listItem.CreatedAt = formattedTime
		listItem.FromAddress = item.FromAddress
		listItem.ToAddress = item.ToAddress
		listItem.Value = item.Value
		listItem.TxnFee = item.TxnFee
		if item.TransactionType == 1 {
			listItem.TransactionType = COIN_TRANSFER
		} else if item.TransactionType == 2 {
			listItem.TransactionType = NEW_TOKEN
		} else if item.TransactionType == 3 {
			listItem.TransactionType = TOKEN_TRANSFER
		} else if item.TransactionType == 4 {
			listItem.TransactionType = NEW_SMART_CONTRACT
		} else if item.TransactionType == 5 {
			listItem.TransactionType = SMART_CONTRACT
		}
		var status string
		if item.Receipt.Status == 1 {
			status = "0x1"
		} else {
			status = "0x0"
		}
		listItem.Status = &status

		listItem.ErrorReason = item.ErrorReason
		listResponse.Items[i] = listItem
	}

	duration := time.Now().Sub(startTime)

	log.Info(relay.InfoTitleListAccountTransactions, relay.MsgAddress, address, relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusNoContent)

	return Response(http.StatusOK,listResponse),	nil
}

func Dump(data interface{}){
	b,_:=json.MarshalIndent(data, "", "  ")
	fmt.Print(string(b))
}