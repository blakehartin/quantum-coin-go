// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * QC Read API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: v1
 */

package qcreadapi

import (
	"fmt"
	"context"
	"encoding/json"
	"github.com/QuantumCoinProject/qc/log"
	"github.com/QuantumCoinProject/qc/relay"
	"github.com/QuantumCoinProject/qc/common"
	"github.com/QuantumCoinProject/qc/common/hexutil"
	"github.com/QuantumCoinProject/qc/rpc"
	"net/http"
	"errors"
	"github.com/mattn/go-colorable"
	"time"
)

// ReadApiAPIService is a service that implements the logic for the ReadApiAPIServicer
// This service should implement the business logic for every endpoint for the ReadApiAPI API.
// Include any external packages or services that will be required by this service.
type ReadApiAPIService struct {
  DpUrl string
}

type RPCTransaction struct {
	BlockHash        *common.Hash      `json:"blockHash"`
	BlockNumber      *hexutil.Big      `json:"blockNumber"`
	From             common.Address    `json:"from"`
	Gas              hexutil.Uint64    `json:"gas"`
	GasPrice         *hexutil.Big      `json:"gasPrice"`
	GasFeeCap        *hexutil.Big      `json:"maxFeePerGas,omitempty"`
	Hash             common.Hash       `json:"hash"`
	Input            hexutil.Bytes     `json:"input"`
	Nonce            hexutil.Uint64    `json:"nonce"`
	To               *common.Address   `json:"to"`
	TransactionIndex *hexutil.Uint64   `json:"transactionIndex"`
	Value            *hexutil.Big      `json:"value"`
	Type             hexutil.Uint64    `json:"type"`
}

// NewReadApiAPIService creates a default api service
func NewReadApiAPIService(dpUrl string) *ReadApiAPIService {
	log.Root().SetHandler(log.LvlFilterHandler(log.Lvl(3), log.StreamHandler(colorable.NewColorableStderr(), log.TerminalFormat(true))))
	return &ReadApiAPIService{DpUrl: dpUrl}
}

// GetLatestBlockDetails - Get latest block details
func (s *ReadApiAPIService) GetLatestBlockDetails(ctx context.Context) (ImplResponse, error) {

	startTime := time.Now()

	log.Info(relay.InfoTitleLatestBlockDetails, relay.MsgDial, s.DpUrl)

	client, err := rpc.Dial(s.DpUrl)
	if err != nil {
		log.Error(relay.MsgDial, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}
	defer client.Close()

	var blockNumber *hexutil.Uint64
	err = client.CallContext(ctx, &blockNumber, "eth_blockNumber")
	if err != nil {
		log.Error(relay.MsgBlockNumber, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}

	latestBlockNumber, err := hexutil.DecodeBig(blockNumber.String())
	if err != nil {
		log.Error(relay.MsgBlockNumber, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusBadRequest)
		return Response(http.StatusBadRequest, nil), errors.New(err.Error())
	}

	duration := time.Now().Sub(startTime)

	log.Info(relay.InfoTitleLatestBlockDetails, "blockNumber", latestBlockNumber.Int64(),  relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusOK)
	l := latestBlockNumber.Int64()
	return Response(http.StatusOK, LatestBlockDetailsResponse{BlockDetails{&l}}), nil
}

// GetAccountDetails - Get account details
func (s *ReadApiAPIService) GetAccountDetails(ctx context.Context, address string) (ImplResponse, error) {

	startTime := time.Now()

	log.Info(relay.InfoTitleAccountDetails, relay.MsgDial, s.DpUrl)

	client, err := rpc.Dial(s.DpUrl)
	if err != nil {
		log.Error(relay.MsgDial, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}
	defer client.Close()

	if !common.IsHexAddress(address) {
		log.Error(relay.MsgAddress, relay.MsgAddress, address, relay.MsgError, relay.ErrInvalidAddress, relay.MsgStatus, http.StatusBadRequest)
		return Response(http.StatusBadRequest, nil), relay.ErrInvalidAddress
	}

	var balance *hexutil.Big
	err = client.CallContext(ctx, &balance, "eth_getBalance", common.HexToAddress(address), "latest")
	if err != nil {
		log.Error(relay.MsgBalance, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}

	var nonce *hexutil.Big
	err = client.CallContext(ctx, &nonce, "eth_getTransactionCount", common.HexToAddress(address), "latest")
	if err != nil {
		log.Error(relay.MsgNonce, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}

	var blockNumber *hexutil.Uint64
	err = client.CallContext(ctx, &blockNumber, "eth_blockNumber")
	if err != nil {
		log.Error(relay.MsgBlockNumber, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}

	accountBalance, err := hexutil.DecodeBig(balance.String())
	if err != nil {
		log.Error(relay.MsgBalance, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusBadRequest)
		return Response(http.StatusBadRequest, nil), errors.New(err.Error())
	}

	accountNonce, err := hexutil.DecodeBig(nonce.String())
	if err != nil {
		log.Error(relay.MsgNonce, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusBadRequest)
		return Response(http.StatusBadRequest, nil), errors.New(err.Error())
	}

	latestBlockNumber, err := hexutil.DecodeBig(blockNumber.String())
	if err != nil {
		log.Error(relay.MsgBlockNumber, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusBadRequest)
		return Response(http.StatusBadRequest, nil), errors.New(err.Error())
	}

	b := accountBalance.String()
	n := accountNonce.Int64()
	l := latestBlockNumber.Int64()

	duration := time.Now().Sub(startTime)

	log.Info(relay.InfoTitleAccountDetails, relay.MsgAddress, address, relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusOK)

	return Response(http.StatusOK, AccountDetailsResponse{
		AccountDetails{&b,&n,&l}}), nil
}

// GetTransactionDetails - Get transaction Details
func (s *ReadApiAPIService) GetTransactionDetails(ctx context.Context, hash string) (ImplResponse, error) {

	startTime := time.Now()
	isDiscarded := false
	discardReason := ""
	log.Info(relay.InfoTitleTransaction, relay.MsgDial, s.DpUrl)

	client, err := rpc.Dial(s.DpUrl)
	if err != nil {
		log.Error(relay.MsgDial,relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}
	defer client.Close()

	if !common.IsHexAddress(hash)  {
		log.Error(relay.MsgHash, relay.MsgHash, hash, relay.MsgError, relay.ErrInvalidHash, relay.MsgStatus, http.StatusBadRequest)
		return  Response(http.StatusBadRequest, nil), relay.ErrInvalidHash
	}

	var raw json.RawMessage
	err =  client.CallContext(ctx, &raw, "eth_getTransactionByHash", common.HexToHash(hash))
	if err != nil {
		log.Error(relay.MsgTransaction, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return  Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}

	if raw != nil {

		var rpcTxn  *RPCTransaction

		err = json.Unmarshal(raw, &rpcTxn);
		if err != nil {
			log.Error(relay.MsgNonce, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusBadRequest)
			return Response(http.StatusBadRequest, nil), errors.New(err.Error())
		}

		var blochHash string
		var blockNumber int64
		var from, gas, gasPrice, txnHash, input, to string

		if rpcTxn.BlockHash != nil{
			blochHash = rpcTxn.BlockHash.String()
		}
		if rpcTxn.BlockNumber != nil {
			b := rpcTxn.BlockNumber.ToInt()
			blockNumber = b.Int64()
		}

		from = rpcTxn.From.String()
		gas = rpcTxn.Gas.String()
		gasPrice = rpcTxn.GasPrice.String()
		txnHash = rpcTxn.Hash.String()
		input = rpcTxn.Input.String()

		if rpcTxn.To != nil {
			to = rpcTxn.To.String()
		}

		transNonce := rpcTxn.Nonce
		n, err := hexutil.DecodeBig(transNonce.String())
		if err != nil {
			log.Error(relay.MsgNonce, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusBadRequest)
			return  Response(http.StatusBadRequest, nil), errors.New(err.Error())
		}

		nonce := n.Int64()

		value := rpcTxn.Value.String()

		var receipt map[string]interface{}
		err =  client.CallContext(ctx, &receipt, "eth_getTransactionReceipt", common.HexToHash(hash))
		if err != nil {
			log.Error(relay.MsgTransactionReceipt, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusServiceUnavailable)
			return  Response(http.StatusServiceUnavailable, nil), errors.New(err.Error())
		}

		var transactionReceipt  TransactionReceipt
		if receipt != nil {
			cumulativeGasUsed := receipt["cumulativeGasUsed"].(string)
			effectiveGasPrice := receipt["effectiveGasPrice"].(string)
			gasUsed := receipt["gasUsed"].(string)
			status := receipt["status"].(string)
			txnReceiptHash := receipt["transactionHash"].(string)
			t := receipt["type"].(string)
			transactionReceipt =  TransactionReceipt{
				cumulativeGasUsed, effectiveGasPrice, gasUsed,
				status, txnReceiptHash, t}
		} else {
			duration := time.Now().Sub(startTime)

			log.Info(relay.InfoTitleTransaction, relay.MsgHash, hash, relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusOK)

			txnDetails := TransactionDetails{
				&blochHash, &blockNumber, discardReason, from,gas, gasPrice, txnHash,
				input, isDiscarded, nonce , &to,value,
				transactionReceipt}

			Dump(txnDetails)

			return  Response(http.StatusOK, TransactionResponse{txnDetails}),	nil
		}
		duration := time.Now().Sub(startTime)

		log.Info(relay.InfoTitleTransaction, relay.MsgHash, hash, relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusOK)

		txnDetails := TransactionDetails{
			&blochHash, &blockNumber, discardReason, from,gas, gasPrice, txnHash,
			input, isDiscarded, nonce , &to,value,
			transactionReceipt}

		Dump(txnDetails)

		return Response(http.StatusOK,TransactionResponse{txnDetails}),	nil
	}

	duration := time.Now().Sub(startTime)

	log.Info(relay.InfoTitleTransaction, relay.MsgHash, hash, relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusNoContent)

	return  Response(http.StatusNotFound,nil), nil
}

func Dump(data interface{}){
	b,_:=json.MarshalIndent(data, "", "  ")
	fmt.Print(string(b))
}